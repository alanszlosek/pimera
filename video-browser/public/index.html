<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Browse Videos</title>

<style>
html {
    -webkit-text-size-adjust: 100%;
}
html,body,button,input,textarea,div,em,a {
    box-sizing: border-box;
    color: #636363;
    font-family: Arial, Helvetica, sans-serif;
    font-size: 1.0em;
    font-weight: normal;
    margin: 0;
    padding: 0;
}
body {
    margin-top: 50px;
}




/*
* {
    font-size: 1.05em;
}
*/

body, button, input, textarea {
}
img {
    width: 100%;
}
button, nav > div {
    background-color: #f7ca88;
    border: 1px solid;
    border-radius: .15em;
    color: #fff;
    cursor: pointer;
    display: inline-block;
    height: auto;
    line-height: 1.7em;
    padding: .3em 1.1em;
    text-align: center;
    vertical-align: middle;
    width: auto;
}
button.active, #tags > .active {
    background-color: #3372b3;
}
button.disabled, #tags > .disabled {
    background-color: #eee;
    border: 1px dashed;
    color: black;
}
input, textarea {
    background-color: #f5f5f5; /*#fbfbfb;*/
    color: #636363;
    border-top: 0px;
    border-right: 0px;
    border-bottom: 1px solid #ccc;
    border-left: 0px;
    padding: 0.2em;
}
input {
    /* This is to gently nudge the input narrower in the tag list above addNote */
    min-width: 60px;
}
button.notice, #nav > div.notice {
    background-color: #ff7c39;
}
.success, button.save {
    background-color: #2084e9 !important;
    color: #fff;
}
.disabled {
    background-color: #ccc !important;
}
.smaller {
    padding: .3em;
}
:focus {
    outline: none;
}

div.search {
    background-color: #fbfbfb;
    color: #636363;
}
div.search input {
    border: 0;
    width: 100%;
}

.flex {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    margin: 0;
    width: auto;
}
.flex > * {
    flex: 1;
    padding-left:0;
}
.flex.one > * {
    flex: 1 1 100%;
}
.flex.three > div {
    flex: 1 1 33.3333%;
}
.flex.four > div {
    flex: 1 1 25%;
}
.flex.five > * {
    flex: 1 1 20%;
}
.flex.six > div {
    flex: 1 1 16.6666%;
}
.flex.seven > div {
    flex: 1 1 14.2857%;
}
.button.smaller {
    font-size: smaller; /*.75em;*/
}

.noscroll {
    overflow: hidden;
}
.overlay {
    background-color: #fff;
    bottom: 0;
    display: none;
    left: 0;
    overflow-y: scroll;
    position: fixed;
    right: 0;
    top: 0;
    z-index: 2;
}
.container {
    margin-left: auto;
    margin-right: auto;
    max-width: 1000px;
}

.right {
    float: right;
}

.hidden {
    display: none;
}

.push {
    margin-bottom: 10px;
}


.main {
    display: grid;
    grid-template-columns: 50% 50%;
}
@media screen and (min-width: 370px) {
    .main {
        grid-template-columns: 33% 33% 33%;
    }
}

.main video {
    width: 100%;
}
.main > div {
    border: 1px solid #fff;
    padding: 2px;
}
.main > div.selected {
    background-color: beige;
}
.main div {
    overflow-wrap:break-word;
}

#nav {
    background-color: #fff;
    position: fixed;
    height: 40px;
    left: 0;
    top: 0;
    width: 100%;
}

#tags {
    /*
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    */
}
#tags > button {
    line-height: 1.2em;
    padding: .6em 0.4em;
}
.tags a {
    margin-right: 10px;
}

#preview {
    background-color: white;
    display: block;
    height: 100vw;
    left: 0px;
    padding: 5px;
    position: absolute;
    top: 0px;
    width: 100vw;
    z-index: 10;
}
#preview > img {
    height: 100%;
    width: 100%;
    object-fit: contain;
}

#recordings {
    padding-left: 38%;
}
#recordings a {
    margin-right: 7px;
}
#playerAndTags {
    position: fixed;
    width: 35%;
}
/*
#playerAndTags {
    height: auto;
    display: grid;
    grid-template-columns: 35% 65%;
}
*/
#videoTag {
    width: 100%;
}
#controls {
    display: grid;
    grid-template-columns: 20% 40% 40%;
}
#videoDuration {
    text-align: right;
}

/*
video::-webkit-media-controls-panel {
    display: flex !important;
    opacity: 1 !important;
}
*/

</style>
</head>
<body id="body">

    <nav class="flex five" id="nav">
        <div id="streamsTabButton">Stream</div>
        <div id="recordingsTabButton">Recordings</div>
        <div id="tagsTabButton">#</div>
        <div id="prevTabButton" data-tab="false">Prev</div>
        <div id="nextTabButton" data-tab="false">Next</div>
    </nav>

    <div id="streamsContainer" class="hidden">
        <div id="streams" class="main" style="display: grid;grid-template-columns: 50% 50%; gap: 1px;">
        </div>
    </div>

    <div id="recordingsContainer" class="hidden">
        <div id="playerAndTags">
            <div id="player">
                <video id="videoTag"></video>
                <div id="controls">
                    <button id="playPause">Play</button>
                    <div id="videoTime"></div>
                    <div id="videoDuration"></div>
                </div>
            </div>
            <div id="tags">tags</div>
        </div>
        <div id="recordings" class="main">

        </div>

    </div>
    <div id="otherContainer"></div>




<script>

var drawChildren = function(container, children) {
    /*
    More room for cool optimizations here:
    - loop through current and desired children, compare using node types, merge differences if possible
    */
    // perhaps compare element ids

    while (container.firstChild) {
        container.removeChild(container.firstChild);
    }
    children.forEach(function(item) {
        if (item == null) {
            return;
        }
        container.appendChild(item);
    });
};

/*
var tag = function(tagName, attributes) {
    var args = Array.prototype.slice.call(arguments);
    tagName = args.shift();
    attributes = args.shift();

    var element = document.createElement(tagName);
    for (var i in attributes) {
        element.setAttribute(i, attributes[i]);
    }
    // Convert text to text node
    for (var i = 0; i < args.length; i ++) {
        var node = args[i];
        if (node == null) {
            continue;
        } else if (node instanceof Node) {
        } else {
            node = document.createTextNode(args[i]);
        }
        element.appendChild(node);
    }

    return element;
};
*/
var tag = function(tagName, attributes, children) {
    var element = document.createElement(tagName);
    for (var i in attributes) {
        element.setAttribute(i, attributes[i]);
    }
    // Convert text to text node
    for (var i = 0; i < children.length; i ++) {
        var node = children[i];
        if (node == null) {
            continue;
        } else if (node instanceof Node) {
        } else {
            node = document.createTextNode(node);
        }
        element.appendChild(node);
    }

    return element;
};


let prettySeconds = function(seconds) {
    //let hours = Math.round(seconds / (60*60));
    //seconds = seconds % SECONDS_IN_HOUR;
    let minutes = Math.round(seconds / 60);
    seconds = Math.round(seconds % 60);
    return ('00' + minutes).slice(-2) + ':' + ('00' + seconds).slice(-2);
};

var handles = {
    body: document.body,
    videos: document.getElementById('recordings'),
    tags: document.getElementById('tags'),
    nav: document.getElementById('nav'),

    streams: document.getElementById('streams'),

    preview: null
};




/*
KEYBOARD INPUT THOUGHTS

* would like left right arrow keys to work as seek
* page up down as faster seek

Questions

* What should advance to next/previous video? up and down arrow keys?

*/
var handlers = {
    body: {
        keydown: function(e) {
            console.log(e)
            // left arrow
            switch (e.key) {
                // backspace
                case 'Backspace':
                    e.preventDefault();
                    e.stopPropagation();
                    archive();
                    break;
                // space functionality should happen naturally, but we need to make sure we set the focus
                case ' ':
                    e.preventDefault();
                    e.stopPropagation();
                    recordings.togglePlay();
                    if (currentlyPlaying) {
                        if (currentlyPlaying.paused) {
                            currentlyPlaying.play();
                        } else {
                            currentlyPlaying.pause();
                        }
                    }
                    break;
                // left arrow
                case 'h':
                case 'ArrowLeft':
                    e.preventDefault();
                    rewind();
                    break;
                // page up
                case 'H':
                    e.preventDefault();
                    rewind(true);
                    break;
                // right arrow
                case 'l':
                case 'ArrowRight':
                    e.preventDefault();
                    forward();
                    break;
                // page down
                case 'L':
                    e.preventDefault();
                    forward(true);
                    break;
                // k key. VIM up, previous video
                case 'k':
                    e.preventDefault();
                    recordings.playPrev();
                    break;
                // j key. VIM down, next video)
                case 'j':
                    e.preventDefault();
                    recordings.playNext();
                    break;
                

                // TAGS
                /*
                case '1':
                    tagVideo(1);
                    break;
                case '2':
                    tagVideo(2);
                    break;
                case '3':
                    tagVideo(3);
                    break;
                case '4':
                    tagVideo(4);
                    break;
                case '5':
                    tagVideo(5);
                    break;
                    */
                
                case 'Escape':
                    if (handles.preview) {
                        handles.preview.remove();
                        handles.preview = null;
                    }
                    break;
                default:
                    console.log(e.keyCode);
                    
            }
        }
    },

    tags: {
        click: function(event) {
            var action = event.target.getAttribute('data-action');
            if (action in recordings) {
                recordings[action](event);
            }
        }
    },
    // hmm, this doesn't quite work. when controls show, they capture the click to play
    recordings: {
        click: function(e) {
            if (e.target.tagName == 'A') {
                var el = e.target;
                e.preventDefault();
                console.log('link');
                handles.preview = tag(
                    'DIV',
                    {
                        id: 'preview',
                        style: 'top: ' + window.scrollY + 'px; height: ' + window.innerHeight + 'px'
                    },
                    [
                        tag('IMG', {src: el.getAttribute('href')}, [])
                    ]
                );
                handles.preview.addEventListener('click', function(el) {
                    handles.preview.remove();
                    handles.preview = null;
                });
                handles.body.appendChild(handles.preview);
            }
            if (e.target.tagName == 'IMG') {
                recordings.play(e.target.parentNode);
            }
            console.log(e.target);
        },
        mouseover: function(e) {
            if (e.target.tagName == 'VIDEO') {
                e.target.setAttribute('controls', 'controls');
            }
        },
        mouseout: function(e) {
            if (e.target.tagName == 'VIDEO') {
                e.target.removeAttribute('controls');
            }
        }
    },
    videoTag: {
        ended: function(e) {
            console.log(e);
            recordings.stateEnded();
            // go to next
            recordings.playNext();
        },
        /*
        loadedmetadata: function(e) {
            videos.loadIndex++;
            videos.loadMeta();
        },
        */
        error: function(e) {
            recordings.playNext();
        },
        playing: function() {
            recordings.statePlaying();
        },
        pause: function() {
            recordings.statePaused();
        },
        /*
        playing: function(e) {
            console.log(e);
            // remove all other borders
            for (let vid of recordings.handles.recordings.children) {
                vid.classList.remove('selected');
            }

            e.target.parentNode.classList.add('selected');
            currentlyPlaying = e.target;
        },
        */
        keys: function(e) {
            e.preventDefault();
        },
        timeupdate: function(e) {
            let tag = e.target;
            if (tag.currentTime) {
                recordings.handles.playbackTime.innerText = prettySeconds(tag.currentTime);
                recordings.handles.videoDuration.innerText = prettySeconds(tag.duration);
            }
        }
    },
    playPause: {
        click: function() {
            recordings.togglePlay();
        }
    },
    prevTabButton: {
        click: function(e) {
            recordings.previous();
            e.stopPropagation();
        }
    },
    nextTabButton: {
        click: function(e) {
            recordings.next();
            e.stopPropagation();
        }
    }
};
// Attach the above handlers
for (var id in handlers) {
    var events = handlers[id];
    for (var event in events) {
        document.getElementById(id).addEventListener(event, events[event]);
    }
}




// CONVERT THE VIDEOS JSON INTO DIV AND VIDEO TAGS
var recordings = {
    handles: {
        container: document.getElementById('recordingsContainer'),
        recordings: document.getElementById('recordings'),
        tags: document.getElementById('tags'),

        videoPlayer: document.getElementById('videoTag'),
        playPause: document.getElementById('playPause'),
        playbackTime: document.getElementById('videoTime'),
        videoDuration: document.getElementById('videoDuration')
    },
    offset: 0,
    limit: 51,
    items: 0,
    loadIndex: 0,
    tagIds: new Set(),
    current: null,

    show: function() {
        let self = this;
        self.handles.container.style.display = 'block';

        self.loadTags();
        this.hidden = false;
    },
    hide: function() {
        let self = this;
        self.handles.container.style.display = 'none';

        self.handles.videoPlayer.pause();
        this.hidden = true;
    },

    loadTags: function() {
        let self = this;
        let tagIds = self.tagIds.size ? '?tagIds=' + Array.from(self.tagIds).join(',') : '';
        fetch('/api/tags' + tagIds)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                var tags = [
                    tag(
                        'button',
                        {'data-action': 'previous'},
                        ['prev']
                    ),
                    tag(
                        'button',
                        {'data-action': 'next'},
                        ['next']
                    ),
                    tag(
                        'button',
                        {'data-action': 'anyTag', 'data-id': 'ANY', 'class': (self.tagIds.size == 0 ? 'active' : '')},
                        ['ANY']
                    ),
                    tag(
                        'button',
                        {'data-action': 'noTags', 'data-id': 'NONE', 'class': (self.tagIds.has('NONE') ? 'active' : '')},
                        ['NONE']
                    )
                ];
                for (var i in data) {
                    var t = data[i];

                    let className;
                    if (self.tagIds.has(t.id)) {
                        className = 'active';
                    } else if (t.count == 0) {
                        className = 'disabled';
                    }
                    
                    tags.push(
                        tag(
                            'button',
                            {
                                'data-id': t.id,
                                'data-action': 'filterByTag',
                                'class': className
                            },
                            [t.tag] // + ' (' + t.count + ')']
                        )
                    );
                }
                drawChildren(self.handles.tags, tags);
            })
            .catch(function(error) {
                console.log(error);
            });;

    },

    load: function() {
        var self = this;
        var url = '/api/files?offset=' + self.offset + '&limit=' + self.limit;
        if (self.tagId != 0) {
            // tagId of -1 returns videos that don't have an tags
            url += '&tagIds=' + Array.from(self.tagIds).join(',');
        }

        fetch(url)
            .then(function(response) {
                return response.json();
            })
            .then(function(files) {
                // this pauses loading
                self.loadIndex = self.limit;
                self.items = files.length;

                let tags = [];
                for (let i = 0; i < files.length; i++) {
                    let video = files[i];
                    let videoImagePrefix = video.path.replace(/\/[0-9]{8}/, '').replace('.mp4', '');

                    var tags2 = [];
                    for (let j = 0; j < video.tags.length; j++) {
                        var tagName = video.tags[j];
                        tags2.push(
                            tag(
                                'A',
                                {href: '/images' + videoImagePrefix + '_' + tagName + '.jpg'},
                                ['#' + tagName]
                            )
                        );
                    }

                    tags.push(
                        tag(
                            'div',
                            {
                                'data-id': video.id,
                                'data-src': '/movies' + video.path,
                                'data-poster': '/images' + videoImagePrefix + '.jpg'
                            },
                            [
                                tag(
                                    'img',
                                    {src: '/images' + videoImagePrefix + '.jpg'},
                                    []
                                ),
                                tag(
                                    'div',
                                    {},
                                    [video.filename]
                                ),
                                tag(
                                    'div',
                                    {},
                                    tags2
                                )
                            ]
                        )
                    )
                }
                drawChildren(self.handles.recordings, tags);
                self.loadIndex = 0;
                self.current = null;
                //self.loadMeta();
            })
            .catch(function(error) {
                console.log(error);
            });
    },

    loadMeta: function() {
        let self = this;
        if (self.items < self.loadIndex) {
            return;
        }
        if (self.loadIndex >= self.limit) {
            return;
        }
        var videoContainer = handles.self.childNodes[ self.loadIndex ];
        let videoTag = self.handles.recordings.childNodes[0];
        videoTag.src = videoTag.getAttribute('data-src');
    },

    anyTag: function(e) {
        let self = this;
        self.offset = 0;
        self.tagIds.clear();
        self.loadTags();
        self.load();
    },
    noTags: function(e) {
        let self = this;
        let tagId = parseInt(e.target.getAttribute('data-id'));
        e.target.classList.toggle('active');
        self.tagIds.delete(tagId);
        if (e.target.classList.contains('active')) {
            self.tagIds.add(tagId);
        }
        self.offset = 0;

        self.tagIds.clear();
        self.tagIds.add('NONE');
        self.loadTags();
        self.load();
    },
    filterByTag: function(e) {
        let self = this;
        // toggle
        // check state, add or remove from filter list as appropriate
        let tagId = parseInt(e.target.getAttribute('data-id'));
        e.target.classList.toggle('active');
        self.tagIds.delete(tagId);
        if (e.target.classList.contains('active')) {
            self.tagIds.add(tagId);
        }
        self.offset = 0;
        //self.tagId = e.target.getAttribute('data-id');
        self.loadTags();
        self.load();
    },
    previous: function(e) {
        let self = this;
        self.offset -= self.limit;
        if (self.offset < 0) {
            self.offset = 0;
        }
        self.load();
    },
    next: function(e) {
        let self = this;
        self.offset += self.limit;
        self.load();
    },

    play: function(div) {
        let self = this;
        self.current = div;

        for (let vid of recordings.handles.recordings.children) {
            vid.classList.remove('selected');
        }
        div.classList.add('selected');

        let y = div.getBoundingClientRect().top + window.scrollY - 50;
        window.scroll({
            top: y,
            behavior: 'smooth'
        });

        self.handles.videoPlayer.poster = div.getAttribute('data-poster');
        self.handles.videoPlayer.src = div.getAttribute('data-src');
        self.handles.videoPlayer.play();
    },
    playNext: function() {
        let self = this;
        if (self.hidden) {
            return;
        }
        if (self.current) {
            if (self.current.nextElementSibling) {
                self.play( self.current.nextElementSibling);
            }
        } else {
            let divs = self.handles.recordings.querySelectorAll('div');
            if (divs.length) {
                self.play(divs[0]);
            }
        }
        /*
         else {
            // nothing current, start at the first video
            var tags = handles.videos.querySelectorAll('div');
            if (tags.length > 0) {
                tags[0].childNodes[0].play();
            }
        
        }
        */
    },
    playPrev: function() {
        let self = this;
        if (self.hidden) {
            return;
        }
        if (self.current) {
            if (self.current.previousElementSibling) {
                self.play( self.current.previousElementSibling);
            }
        }
        /*
         else {
            // nothing current, start at the first video
            var tags = handles.videos.querySelectorAll('div');
            if (tags.length > 0) {
                tags[0].childNodes[0].play();
            }
        
        }
        */
    },
    togglePlay: function() {
        if (self.hidden) {
            return;
        }
        if (this.playing) {
            this.handles.videoPlayer.pause();
            this.handles.playPause.innerText = 'Play';
        } else {
            this.handles.videoPlayer.play();
            this.handles.playPause.innerText = 'Pause';
        }
    },
    
    statePlaying: function() {
        this.playing = true;
        this.handles.playPause.innerText = 'Pause';
    },
    stateEnded: function() {
        recordings.playing = false;
        this.handles.playPause.innerText = 'Play';
    },
    statePaused: function() {
        recordings.playing = false;
        this.handles.playPause.innerText = 'Play';
    }
};



var rewind = function(big) {
    if (currentlyPlaying) {
        var offset = big ? 20.0 : 5.0;
        //currentlyPlaying.fastSeek( currentlyPlaying.currentTime - offset);
        currentlyPlaying.currentTime -= offset;
    }
};
var forward = function(big) {
    if (currentlyPlaying) {
        var offset = big ? 20.0 : 5.0;
        //currentlyPlaying.fastSeek( currentlyPlaying.currentTime + offset);
        currentlyPlaying.currentTime += offset;
    }
};


//videos.init();
//videos.load();

let streams = {
    handles: {
        container: document.getElementById('streamsContainer'),
        streams: document.getElementById('streams')
    },
    intervalHandle: null,
    cameras: {},
    show: function() {
        let self = this;

        self.handles.container.style.display = 'block';

        let fetchCameras = function() {
            fetch('/api/cameras.json')
                .then(function(response) {
                    return response.json();
                })
                .then(function(data) {
                    for (let key in self.cameras) {
                        if (!(key in data)) {
                            // remove
                            self.handles.streams.removeChild( self.cameras[key] );
                            delete self.cameras[key];
                            delete handles[key];
                        }
                    }
                    for (let key in data) {
                        if (key in self.cameras) {
                        } else {
                            console.log('not found ' + key);
                            // add
                            //let id = 'cam_' + getRandomInt(1, 200);

                            let img = tag('IMG', {}, []);
                            img.src = 'http://' + key + ':8080/stream.mjpeg?ts=' + Date.now();

                            self.cameras[ key ] = tag('DIV', {}, [img]);
                            /*
                            if (!(key == '192.168.1.167' || key == '192.168.1.177')) {
                                handles[key] = img;
                            }
                            */
                            self.handles.streams.appendChild(self.cameras[key]);
                        }
                    }
                })
                .catch(function(error) {
                    console.log(error);
                });
        };
        fetchCameras();
        self.intervalHandle = setInterval(fetchCameras, 1000);
    },
    hide: function() {
        let self = this;
        clearInterval( self.intervalHandle );

        for (let key in self.cameras) {
            self.handles.streams.removeChild( self.cameras[key]);
        }
        self.cameras = {};
    }
};


let modules = {
    'streams': streams,
    'recordings': recordings
};







let tabs = {
    'streamsTabButton': 'streams',
    'recordingsTabButton': 'recordings'
};
// TODO convert this to id and event struct?
handles.nav.addEventListener('click', function (event) {
    var target = event.target;
    if (target.tagName == 'I') {
        target = target.parentNode;
    }
    if (target.getAttribute('data-tab') == 'false') {
        event.stopPropagation();
        return;
    }

    let id = target.getAttribute('id');
    showTab(id);
});
var showTab = function (id) {
    let container = tabs[id];
    //app.tab = index;
    console.log(id);
    for (let key in tabs) {
        let value = tabs[key];
        if (key == id) {
            document.getElementById(key).classList.add('success');
            //document.getElementById(value).style.display = 'block';
            modules[value].show();
            //modules[i].show();
            //current = modules[i];

            
        } else {
            document.getElementById(key).classList.remove('success');
            //document.getElementById(value).style.display = 'none';
            modules[value].hide();
        }
    };
};

</script>
</body>
</html>
